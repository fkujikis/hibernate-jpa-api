<?xml version="1.0" encoding="UTF-8"?>
<chapter id="search-configuration">
  <title>Configuration</title>

  <section id="search-configuration-directory" revision="1">
    <title>Directory configuration</title>

    <para>Apache Lucene has a notion of Directory where the index is stored.
    The Directory implementation can be customized but Lucene comes bundled
    with a file system and a full memory implementation.
    <productname>Hibernate Search</productname> has the notion of
    <literal>DirectoryProvider</literal> that handle the configuration and the
    initialization of the Lucene Directory.</para>

    <table>
      <title>List of built-in Directory Providers</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry align="center">Class</entry>

            <entry align="center">description</entry>

            <entry align="center">Properties</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>org.hibernate.search.store.FSDirectoryProvider</entry>

            <entry>File system based directory. The directory used will be
            &lt;indexBase&gt;/&lt; <literal>@Indexed.name</literal>
            &gt;</entry>

            <entry><literal>indexBase</literal> : Base directory</entry>
          </row>

          <row>
            <entry>org.hibernate.search.store.RAMDirectoryProvider</entry>

            <entry>Memory based directory, the directory will be uniquely
            indentified by the <literal>@Indexed.name</literal>
            element</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>org.hibernate.search.store.FSMasterDirectoryProvider</entry>

            <entry><para>File system based directory. Like
            FSDirectoryProvider. It also copy the index to a source directory
            (aka copy directory) on a regular basis. </para><para>The
            recommended value for the refresh period is (at least) 50% higher
            that the time to copy the information (default 3600 seconds - 60
            minutes).</para><para>Note that the copy is based on an
            incremental copy mechanism reducing the average copy
            time.</para><para>DirectoryProvider typically used on the master
            node in a JMS back end cluster.</para>DirectoryProvider typically
            used on slave nodes using a JMS back end.</entry>

            <entry><para><literal>indexBase</literal>: Base
            directory</para><para><literal>sourceBase</literal>: Source (copy)
            base directory.</para><para><literal>source</literal>: Source
            directory suffix (default to <literal>@Indexed.name</literal>).
            The actual source directory name being
            <filename>&lt;sourceBase&gt;/&lt;source&gt;</filename>
            </para><para>refresh: refresh period in second (the copy will take
            place every refresh seconds).</para></entry>
          </row>

          <row>
            <entry>org.hibernate.search.store.FSSlaveDirectoryProvider</entry>

            <entry><para>File system based directory. Like
            FSDirectoryProvider. But retrieve a master version (source) on a
            regular basis. To avoid locking and inconsistent search results, 2
            local copies are kept. </para><para>The recommended value for the
            refresh period is (at least) 50% higher that the time to copy the
            information (default 3600 seconds - 60 minutes).</para><para>Note
            that the copy is based on an incremental copy mechanism reducing
            the average copy time.</para><para>DirectoryProvider typically
            used on slave nodes using a JMS back end.</para></entry>

            <entry><para><literal>indexBase</literal>: Base
            directory</para><para><literal>sourceBase</literal>: Source (copy)
            base directory.</para><para><literal>source</literal>: Source
            directory suffix (default to <literal>@Indexed.name</literal>).
            The actual source directory name being
            <filename>&lt;sourceBase&gt;/&lt;source&gt;</filename>
            </para><para>refresh: refresh period in second (the copy will take
            place every refresh seconds).</para></entry>
          </row>

          <row>
            <entry>org.hibernate.search.store.RAMDirectoryProvider</entry>

            <entry>Memory based directory, the directory will be uniquely
            identified (in the same deployment unit) by the
            <literal>@Indexed.name</literal> element</entry>

            <entry>none</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>If the built-in directory providers does not fit your needs, you can
    write your own directory provider by implementing the
    <classname>org.hibernate.store.DirectoryProvider</classname>
    interface</para>

    <para>Each indexed entity is associated to a Lucene index (an index can be
    shared by several entities but this is not usually the case). You can
    configure the index through properties prefixed by
    <constant>hibernate.search.</constant>
    <replaceable>indexname</replaceable> . Default properties inherited to all
    indexes can be defined using the prefix
    <constant>hibernate.search.default.</constant></para>

    <para>To define the directory provider of a given index, you use the
    <constant>hibernate.search. <replaceable>indexname</replaceable>
    .directory_provider </constant></para>

    <programlisting>hibernate.search.default.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.default.indexBase=/usr/lucene/indexes

hibernate.search.Rules.directory_provider org.hibernate.search.store.RAMDirectoryProvider        </programlisting>

    <para>applied on</para>

    <programlisting>@Indexed(name="Status")
public class Status { ... }

@Indexed(name="Rules")
public class Rule { ... }</programlisting>

    <para>will create a file system directory in
    <filename>/usr/lucene/indexes/Status</filename> where the Status entities
    will be indexed, and use an in memory directory named
    <literal>Rules</literal> where Rule entities will be indexed.</para>

    <para>So you can easily defined common rules like the directory provider
    and base directory, and overide those default later on on a per index
    basis.</para>

    <para>Writing your own <classname>DirectoryProvider</classname> , you can
    benefit this configuration mechanism too.</para>
  </section>

  <section>
    <title>Worker and Back ends configuration</title>

    <para>Hibernate Search works done by a worker you can configure. The
    default (and only) worker today use transactional scoping.</para>

    <section>
      <title>Generic configuration</title>

      <para>You can define the worker configuration using the following
      properties</para>

      <para></para>

      <table>
        <title>worker configuration</title>

        <tgroup cols="2">
          <colspec align="center" />

          <tbody>
            <row>
              <entry>property</entry>

              <entry>description</entry>
            </row>

            <row>
              <entry><literal>org.hibernate.worker.backend</literal></entry>

              <entry>Out of the box support for the Apache Lucene back end and
              the JMS back end. Default to <literal>lucene</literal>. Supports
              also <literal>jms</literal>.</entry>
            </row>

            <row>
              <entry><literal>org.hibernate.worker.execution</literal></entry>

              <entry>Supports synchronous and asynchrounous execution. Default
              to <literal><literal>sync</literal></literal>. Supports also
              <literal>async</literal>.</entry>
            </row>

            <row>
              <entry><literal>org.hibernate.worker.thread_pool.size</literal></entry>

              <entry>Defines the number of threads in the pool. useful only
              for asynchrounous execution. Default to 1.</entry>
            </row>

            <row>
              <entry><literal>org.hibernate.worker.buffer_queue.max</literal></entry>

              <entry>Defines the maximal number of work queue if the thread
              poll is starved. Useful only for asynchrounous execution.
              Default to infinite. If the limit is reached, the work is done
              by the main thread.</entry>
            </row>

            <row>
              <entry><literal>org.hibernate.worker.jndi.*</literal></entry>

              <entry>Defines the JNDI properties to initiate the
              InitialContext (if needed). JNDI is only used by the JMS back
              end.</entry>
            </row>

            <row>
              <entry><literal>
              org.hibernate.worker.jms.connection_factory</literal></entry>

              <entry>Mandatory for the JMS back end. Defines the JNDI name to
              lookup the JMS connection factory from
              (<literal>java:/ConnectionFactory</literal> by default in JBoss
              AS)</entry>
            </row>

            <row>
              <entry><literal>
              org.hibernate.worker.jms.queue</literal></entry>

              <entry>Mandatory for the JMS back end. Defines the JNDI name to
              lookup the JMS queue from. The queue will be used to post work
              messages.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>JMS Back end</title>

      <para>This chapter describes in greater detail how to configure the
      Master / Slaves Hibernate Search architecture.</para>

      <section>
        <title>Slave nodes</title>

        <para>Every index update operation is sent to a JMS queue. Index
        quering operations are executed on a local index copy.</para>

        <programlisting>### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSSlaveDirectoryProvider

## Backend configuration
hibernate.search.worker.backend = jms
hibernate.search.worker.jms.connection_factory = java:/ConnectionFactory
hibernate.search.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# org.hibernate.worker.execution = async
# org.hibernate.worker.thread_pool.size = 2
# org.hibernate.worker.buffer_queue.max = 50</programlisting>

        <para>A file system local copy is recommended for faster search
        results.</para>

        <para>The refresh period should be higher that the expected time
        copy.</para>
      </section>

      <section>
        <title>Master node</title>

        <para>Every index update operation is taken fron a JMS queue and
        executed. The master index(es) is(are) copied on a regular
        basis.</para>

        <programlisting>### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSMasterDirectoryProvider

## Backend configuration
#Backend is the default lucene one</programlisting>

        <para>The refresh period should be higher that the expected time
        copy.</para>

        <para>In addition to the Hibernate Search framework configuration, a
        Message Driven Bean should be written and set up to process index
        works queue through JMS.</para>

        <programlisting>@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType", propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination", propertyValue="queue/hiebrnatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController implements MessageListener {
    @PersistenceContext EntityManager em;
    
    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session) 
    }
}</programlisting>

        <para>This example inherit the abstract JMS controller class available
        and implements a JavaEE 5 MDB. This implementation is given as an
        example and, while most likely ;ore complex, can be adjusted to make
        use of non Java EE Message Driven Beans. For more information about
        the <methodname>getSession()</methodname> and
        <methodname>cleanSessionIfNeeded()</methodname>, please check
        <classname>AbstractJMSHibernateSearchController</classname>'s
        javadoc.</para>

        <remark>Hibernate Search test suite makes use of JBoss Embedded to
        test the JMS integration. It allows the unit test to run both the MDB
        container and JBoss Messaging (JMS provider) in a standalone way
        (marketed by some as "lightweight"). </remark>
      </section>
    </section>
  </section>

  <section id="search-configuration-event" revision="1">
    <title>Enabling automatic indexing</title>

    <para>Automatic indexing is enable out of the box when using Hibernate
    Annotations or Hibernate EntityManager. If, for some reason you need to
    disable that, set
    <literal>hibernate.search.autoregister_listeners</literal> to false. Note
    that there is no performance runtime when the listeners are enabled while
    no entity is indexable.</para>

    <para>To enable automatic indexing in Hibernate Core, add the
    <literal>SearchEventListener</literal> for the three Hibernate events that
    occur after changes are executed to the database. Once again, such a
    configuration is not useful with Hibernate Annotations or Hibernate
    EntityManager.</para>

    <programlisting>&lt;hibernate-configuration&gt;
    ...
    &lt;event type="post-update"
        &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="post-insert"
        &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="post-delete"
        &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</programlisting>
  </section>
</chapter>