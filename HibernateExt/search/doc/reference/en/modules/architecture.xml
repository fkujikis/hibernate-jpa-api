<?xml version="1.0" encoding="UTF-8"?>
<chapter id="search-architecture">
  <title>Architecture</title>

  <para>Hibernate Search is made of an indexing engine and an index search
  engine. Both are backed by Apache Lucene.</para>

  <para>When an entity is inserted, updated or removed to/from the database,
  <productname>Hibernate Search</productname> keeps track of this event
  (through the Hibernate event system) and schedule an index update. All the
  index updates are handled for you without you having to use the Apache
  Lucene APIs.</para>

  <para>To interact with Apache Lucene indexes, Hibernate Search has the
  notion of <classname>DirectoryProvider</classname> . A directory provider
  will manage a given Lucene <classname>Directory</classname> type. You can
  configure directory providers to adjust the directory target.</para>

  <para><productname>Hibernate Search</productname> can also use a Lucene
  index to search an entity and return a (list of) managed entity saving you
  from the tedious Object / Lucene Document mapping and low level Lucene APIs.
  The same persistence context is shared between Hibernate and Hibernate
  Search ; as a matter of fact, the Seearch Session is built on top of the
  Hibernate Session. The application code use the unified
  <classname>org.hibernate.Query</classname> API exactly the way a HQL or
  native query would be done.</para>

  <section>
    <title>Batching Scope</title>

    <para>To be more efficient, Hibernate Search batch the interactions with
    the Lucene index. There is currently two types of batching depending on
    the expected scope.</para>

    <para>When out of transaction, the index update operation is executed
    right after the actual database operation. This scope is really a no
    scoping, and no batching is performed.</para>

    <para>It is however recommended, for both your database and Hibernate
    Search, to execute your operation in a transaction (whether it be JDBC or
    JTA). When in a transaction, the index update operation is schedule for
    the transaction commit (and discarded in case of transaction rollback).
    The batching scope is the transaction. There is 2 immediate
    benefits:</para>

    <itemizedlist>
      <listitem>
        <para>performance: Lucene indexing works better when operation are
        executed in batch.</para>
      </listitem>

      <listitem>
        <para>ACIDity: The work executed has the same scoping as the one
        executed by the database transaction and is executed if and only if
        the transaction is committed.</para>

        <note>
          <para>Disclamer, the work in not ACID in the strict sense of it, but
          ACID behavior is rarely useful for full text search indexes since
          they can be rebuilt from the source at any time.</para>
        </note>
      </listitem>
    </itemizedlist>

    <para>You can think of those two scopes (no scope vs transactional) as the
    equivalent of the (infamous) autocommit vs transactional behavior. From a
    performance perspective, the <emphasis>in transaction</emphasis> mode is
    recommended. The scoping choice is made transparently: Hibernate Search
    detects the presence of a transaction and adjust the scoping.</para>

    <remark>Note that Hibernate Search works perfectly fine in the Hibernate /
    EntityManager long conversation pattern aka. atomic conversation.</remark>

    <para>Depending on user demand, additional scoping will be considered, the
    pluggability mechanism being already in place.</para>
  </section>

  <section>
    <title>Back end</title>

    <para>Hibernate Search offers the ability to let the scoped work being
    processed by different back ends. Two back ends are provided out of the
    box for 2 different scenarii.</para>

    <section>
      <title>Lucene</title>

      <para>In this mode, all index update operations applied on a given node
      (JVM) will be executed to the Lucene directories (through the directory
      providers) by the same node. This mode is typically used in non
      clustered mode or in clustered mode where the directory store is
      shared.</para>

      <mediaobject>
        <imageobject role="html">
          <imagedata align="center"
                     fileref="../shared/images/lucene-backend.png"
                     format="PNG" />
        </imageobject>

        <imageobject role="fo">
          <imagedata align="center" fileref="images/lucene-backend.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>

      <para>This mode targets non clustered applications, or clustered
      applications where the Directory is taking care of the locking
      strategy.</para>

      <para>The main advantage is simplicity and immediate visibility of the
      changes in Lucene queries (a requirement is some applications).</para>
    </section>

    <section>
      <title>JMS</title>

      <para>All index update operations applied on a given node are sent to a
      JMS queue. A unique reader will then process the queue and update the
      master Lucene index. The master index is then replicated on a regular
      basis to the slave copies. This is known as the master / slaves pattern.
      The master is the sole responsible for updating the Lucene index, the
      slaves can accept read/write operations, process the read operation on
      their local index copy, and delegate the update operations to the
      master.</para>

      <mediaobject>
        <imageobject role="html">
          <imagedata align="center" fileref="../shared/images/jms-backend.png"
                     format="PNG" />
        </imageobject>

        <imageobject role="fo">
          <imagedata align="center" fileref="images/jms-backend.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>

      <para>This mode targets clustered environments where throughput is
      critical, and index update delays are affordable. Reliability is ensured
      by the JMS provider and by having the slaves working on a local copy of
      the index.</para>
    </section>

    <section>
      <title>Custom</title>

      <para>Hibernate Search is an extensible architecture. While not yet part
      of the public API, pluging a third party back end is possible. Feel free
      to drop ideas to
      <literal>hibernate-dev@lists.jboss.org</literal>.</para>
    </section>
  </section>

  <section>
    <title>Work execution</title>

    <para>The indexing work (done by the back end) can be executed
    synchronously with the transaction commit (or update operation if out of
    transaction), or asynchronously.</para>

    <section>
      <title>Synchronous</title>

      <para>This is the safe mode where the back end work is executed in
      concert with the transaction commit. Under highly concurrent
      environment, this can lead to throughput limitation (due to the Apache
      Lucene lock mechanism). It can increase the system response time too if
      the backend is significantly slower than the transactional process and
      if a lot of IO operations are involved.</para>
    </section>

    <section>
      <title>Asynchronous</title>

      <para>This mode delegates the work done by the back end to a different
      thread. That way, throughput and response time are (to a certain extend)
      decorrelated from the back end performance. The drawback is that a small
      delay appears between the transaction commit and the index update and a
      small overhead is introduced to deal with thread management.</para>

      <para>It is recommended to use synchronous execution first and evaluate
      asynchronous if performance problems occur and after having set up a
      proper benchmark (ie not a lonely cowboy hitting the system in a
      completely unrealistic way).</para>
    </section>
  </section>
</chapter>